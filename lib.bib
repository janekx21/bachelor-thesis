@book{ahoTheoryParsingTranslation1972,
  title = {The Theory of Parsing, Translation, and Compiling. 1: {{Parsing}}},
  shorttitle = {The Theory of Parsing, Translation, and Compiling. 1},
  author = {Aho, Alfred V. and Ullman, Jeffrey D.},
  year = {1972},
  publisher = {Prentice-Hall},
  address = {Englewood Cliffs, NJ},
  isbn = {978-0-13-914556-8},
  langid = {english},
  file = {/home/janek/Zotero/storage/WQ6NBQAK/The theory of parsing, translation, and compiling.pdf}
}

@incollection{beyerSoftwareVerificationTesting2017,
  title = {Software {{Verification}}: {{Testing}} vs. {{Model Checking}}},
  shorttitle = {Software {{Verification}}},
  booktitle = {Hardware and {{Software}}: {{Verification}} and {{Testing}}},
  author = {Beyer, Dirk and Lemberger, Thomas},
  editor = {Strichman, Ofer and {Tzoref-Brill}, Rachel},
  year = {2017},
  volume = {10629},
  pages = {99--114},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-70389-3_7},
  url = {http://link.springer.com/10.1007/978-3-319-70389-3\_7},
  urldate = {2024-11-19},
  abstract = {In practice, software testing has been the established method for finding bugs in programs for a long time. But in the last 15 years, software model checking has received a lot of attention, and many successful tools for software model checking exist today. We believe it is time for a careful comparative evaluation of automatic software testing against automatic software model checking. We chose six existing tools for automatic test-case generation, namely AFL-fuzz, CPATiger, Crest-ppc, FShell, Klee, and PRtest, and four tools for software model checking, namely Cbmc, CPA-Seq, Esbmc-incr, and Esbmc-kInd, for the task of finding specification violations in a large benchmark suite consisting of 5 693 C programs. In order to perform such an evaluation, we have implemented a framework for test-based falsification (TBF) that executes and validates test cases produced by test-case generation tools in order to find errors in programs. The conclusion of our experiments is that software model checkers can (i) find a substantially larger number of bugs (ii) in less time, and (iii) require less adjustment to the input programs.},
  isbn = {978-3-319-70388-6 978-3-319-70389-3},
  langid = {english},
  file = {/home/janek/Zotero/storage/KBP89X3T/Beyer and Lemberger - 2017 - Software Verification Testing vs. Model Checking.pdf}
}

@article{boehmRopesAlternativeStrings1995,
  title = {Ropes: {{An}} Alternative to Strings},
  shorttitle = {Ropes},
  author = {Boehm, Hans-J. and Atkinson, Russ and Plass, Michael},
  year = {1995},
  month = dec,
  journal = {Software: Practice and Experience},
  volume = {25},
  number = {12},
  pages = {1315--1330},
  issn = {0038-0644, 1097-024X},
  doi = {10.1002/spe.4380251203},
  url = {https://onlinelibrary.wiley.com/doi/10.1002/spe.4380251203},
  urldate = {2024-08-23},
  abstract = {Programming languages generally provide a `string' or `text' type to allow manipulation of sequences of characters. This type is usually of crucial importance, since it is normally mentioned in most interfaces between system components. We claim that the traditional implementations of strings, and often the supported functionality, are not well suited to such general-purpose use. They should be confined to applications with specific, and unusual, performance requirements. We present `ropes' or `heavyweight' strings as an alternative that, in our experience leads to systems that are more robust, both in functionality and in performance.},
  copyright = {http://onlinelibrary.wiley.com/termsAndConditions\#vor},
  langid = {english},
  file = {/home/janek/Zotero/storage/G4V5UZN5/Boehm et al. - 1995 - Ropes An alternative to strings.pdf}
}

@article{borsottiFastGLRParsers2021a,
  title = {Fast {{GLR}} Parsers for Extended {{BNF}} Grammars and Transition Networks},
  author = {Borsotti, Angelo and Breveglieri, Luca and Crespi Reghizzi, Stefano and Morzenti, Angelo},
  year = {2021},
  month = jun,
  journal = {Journal of Computer Languages},
  volume = {64},
  pages = {101035},
  issn = {2590-1184},
  doi = {10.1016/j.cola.2021.101035},
  url = {https://www.sciencedirect.com/science/article/pii/S2590118421000149},
  urldate = {2023-10-27},
  abstract = {The Tomita's Generalized LR(1) parsing algorithm (GLR), later improved in many ways, runs in a linear time on LR(1) grammars, and degrades to a polynomial-time bound if the grammar is not deterministic. We address a useful feature not present in the current GLR(1) methods: the ability to accept grammars of the Extended BNF type (EBNF), the rules of which contain regular expressions. An EBNF grammar is conveniently represented by a collection of finite automata called a Transition Net (TN). We define, analyze and evaluate a new GLR(1) algorithm, called GELR, that combines the recent LR(1) parsing algorithm for TNs with the classical GLR data structures: the Graph-Structured Stack representing multiple stacks, and the Shared Packed Parse Forest for multiple syntax trees. The GELR algorithm is proved correct and an efficient implementation incorporating the state-of-the-art Right-Nulled parsing optimization is available. Experimental measures of the GELR parser size, speed and memory footprint are reported for current programming and web languages, and are compared with those of other parsing algorithms. The findings prove that directly parsing EBNF grammars does not penalize speed. Performance comparisons for different computer languages should also be of interest.},
  keywords = {GLR parsing,Graph-structured stack,GSS,Infinite ambiguity,Parser performance comparison,Regular right-hand side grammar,Shared packed parse forest,SPPF},
  file = {/home/janek/Zotero/storage/WJW2ZMFP/Borsotti et al. - 2021 - Fast GLR parsers for extended BNF grammars and tra.pdf;/home/janek/Zotero/storage/M97BT8M5/S2590118421000149.html}
}

@misc{briceVisualVsText2024,
  title = {Visual vs Text Based Programming, Which Is Better?},
  author = {Brice, Andy},
  year = {2024},
  month = jan,
  journal = {Successful Software},
  url = {https://successfulsoftware.net/2024/01/16/visual-vs-text-based-programming-which-is-better/},
  urldate = {2024-11-21},
  abstract = {Visual programming tools (also called `no-code' or `low-code') have been getting a lot of press recently. This, in turn, has generated a lot of discussion about whether visu{\dots}},
  langid = {english}
}

@misc{emeleOpenEnergyOntology2024,
  title = {Open {{Energy Ontology}} ({{OEO}})},
  author = {Emele, Lukas and Stappel, Mirjam and Kleinau, Anna and Hastings, Janna and Sehn, Vera and F{\"o}rster, Hannah and Kuckertz, Patrick and {Hoyer-Klick}, Carsten and Hofmann, Christian and Knosala, Kevin and H{\"u}lk, Ludwig and Killicarslan, Izzet and Drathschmidt, Franziska and Simon, Fl{\"u}gel and Ulrich, Frey and Muschner, Christoph and Winger, Christian and Neuhaus, Fabian and Christmann, Lara and Glauer, Martin and Duc, Pierre-Francois and Cordes, Sebastian and Pehl, Michaja and Schnepf, Kai and Mossakowski, Till and Stage, Alexander and Gardian, Hedda and Arellano Ruiz, Eugenio Salvador and Rothk{\"o}tter, Markus and R{\"u}licke, Linda and Seibicke, Alexandra and Mittermeier, Ludwig and M{\"u}ller, Ulf and K{\"o}hler, Nele and Spinde, Hannah and Wichern, Viktor and Zielke, Norman and Stucky, Uwe and Breitkreutz, Madeleine and Gerlach, Lilly and Heidfeld, Colin},
  year = {2024},
  month = sep,
  url = {https://github.com/OpenEnergyPlatform/ontology},
  urldate = {2024-11-21},
  abstract = {Repository for the Open Energy Ontology (OEO)},
  copyright = {CC0-1.0}
}

@book{flickIntroductionQualitativeResearch2011,
  title = {An Introduction to Qualitative Research},
  author = {Flick, Uwe and Flick, Uwe},
  year = {2011},
  edition = {4. ed., repr},
  publisher = {SAGE},
  address = {Los Angeles, Calif.},
  isbn = {978-1-84787-323-1 978-1-84787-324-8},
  langid = {english},
  file = {/home/janek/Zotero/storage/3MY4K48B/Flick and Flick - 2011 - An introduction to qualitative research.pdf}
}

@book{gunasingheLanguageServerProtocol2022,
  title = {Language {{Server Protocol}} and {{Implementation}}: {{Supporting Language-Smart Editing}} and {{Programming Tools}}},
  shorttitle = {Language {{Server Protocol}} and {{Implementation}}},
  author = {Gunasinghe, Nadeeshaan and Marcus, Nipuna},
  year = {2022},
  publisher = {Apress},
  address = {Berkeley, CA},
  doi = {10.1007/978-1-4842-7792-8},
  url = {https://link.springer.com/10.1007/978-1-4842-7792-8},
  urldate = {2024-10-08},
  copyright = {https://www.springer.com/tdm},
  isbn = {978-1-4842-7791-1 978-1-4842-7792-8},
  langid = {english},
  keywords = {Code editors,Completions,Interactive Developer Environment (IDE),Language Intelligence,Language Intelligence Tools,Language Server,Language Server Extensions,Language Server Protocal,Language Service,LSP,Plugins,Standard I/O,Websocket},
  file = {/home/janek/Zotero/storage/9VW4HV5D/Gunasinghe and Marcus - 2022 - Language Server Protocol and Implementation Suppo.pdf}
}

@misc{HelixEditorDocumentation,
  title = {Helix {{Editor Documentation}}},
  url = {https://docs.helix-editor.com/languages.html},
  urldate = {2024-11-19},
  file = {/home/janek/Zotero/storage/RTEP6R9X/languages.html}
}

@book{hopcroftIntroductionAutomataTheory1979,
  title = {Introduction to Automata Theory, Languages, and Computation},
  author = {Hopcroft, John E. and Ullman, Jeffrey D.},
  year = {1979},
  series = {Addison-{{Wesley}} Series in Computer Science},
  publisher = {Addison-Wesley},
  address = {Reading, Mass.},
  url = {http://www.gbv.de/dms/hebis-mainz/toc/02558085X.pdf},
  urldate = {2024-11-21},
  abstract = {This book presents automata theory, formal languages, and computational complexity as a coherent theory. It includes end-of-chapter questions, bibliographies, and exercises. Problems of highest and intermediate difficulty are marked respectively with double or single stars.},
  isbn = {978-0-201-02988-8},
  langid = {english},
  keywords = {Automata theory,Automates mathematiques theorie des,Complexite de calcul (informatique),Complexite de calcul (Informatique),Computational complexity,Computers,Formal languages,Formele talen,Langages formels,Machine theory,Programmeren (computers),Theorie des automates},
  annotation = {OCLC: 4549363}
}

@book{hopcroftIntroductionAutomataTheory2007,
  title = {Introduction to Automata Theory, Languages, and Computation},
  author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
  year = {2007},
  edition = {3. ed},
  publisher = {Pearson},
  address = {Bosten San Francisco Munich},
  isbn = {978-0-321-45536-9},
  langid = {english},
  file = {/home/janek/Zotero/storage/337XVDCE/Hopcroft-Motwani-Ullman-2001.pdf}
}

@misc{HydroprojectRustsitter2024,
  title = {Hydro-Project/Rust-Sitter},
  year = {2024},
  month = oct,
  url = {https://github.com/hydro-project/rust-sitter},
  urldate = {2024-10-10},
  abstract = {Use Tree Sitter to parse your own languages in Rust},
  copyright = {MIT},
  howpublished = {Hydro}
}

@article{ironsExperienceExtensibleLanguage1970,
  title = {Experience with an Extensible Language},
  author = {Irons, Edgar},
  year = {1970},
  month = jan,
  journal = {Communications of the ACM},
  volume = {13},
  pages = {31--40},
  doi = {10.1145/361953.361966},
  abstract = {An operational extensible language system is described. The system and its base language are appraised with respect to efficiency, flexibility, and utility for different categories of users.},
  file = {/home/janek/Zotero/storage/QDNNW2D4/Irons - 1970 - Experience with an extensible language.pdf}
}

@article{knuthTranslationLanguagesLeft1965,
  title = {On the Translation of Languages from Left to Right},
  author = {Knuth, Donald E.},
  year = {1965},
  month = dec,
  journal = {Information and Control},
  volume = {8},
  number = {6},
  pages = {607--639},
  issn = {0019-9958},
  doi = {10.1016/S0019-9958(65)90426-2},
  url = {https://www.sciencedirect.com/science/article/pii/S0019995865904262},
  urldate = {2024-11-21},
  abstract = {There has been much recent interest in languages whose grammar is sufficiently simple that an efficient left-to-right parsing algorithm can be mechanically produced from the grammar. In this paper, we define LR(k) grammars, which are perhaps the most general ones of this type, and they provide the basis for understanding all of the special tricks which have been used in the construction of parsing algorithms for languages with simple structure, e.g. algebraic languages. We give algorithms for deciding if a given grammar satisfies the LR(k) condition, for given k, and also give methods for generating recognizes for LR(k) grammars. It is shown that the problem of whether or not a grammar is LR(k) for some k is undecidable, and the paper concludes by establishing various connections between LR(k) grammars and deterministic languages. In particular, the LR(k) condition is a natural analogue, for grammars, of the deterministic condition, for languages.},
  file = {/home/janek/Zotero/storage/39CY9NA8/Knuth - 1965 - On the translation of languages from left to right.pdf;/home/janek/Zotero/storage/WRFVGGDH/S0019995865904262.html}
}

@inproceedings{langDeterministicTechniquesEfficient1974,
  title = {Deterministic {{Techniques}} for {{Efficient Non-Deterministic Parsers}}},
  booktitle = {Lecture {{Notes}} in {{Computer Science}}},
  author = {Lang, Bernard},
  year = {1974},
  month = jul,
  volume = {14},
  pages = {255--269},
  doi = {10.1007/3-540-06841-4_65},
  abstract = {A general study of parallel non-deterministic parsing and translation {\`a} la Earley is developped formally, based on non-deterministic pushdown acceptor-transducers. Several results (complexity and efficiency) are established, some new and other previously proved only in special cases. As an application, we show that for every family of deterministic context-free pushdown parsers (e.g. precedence, LR(k), LL(k), ...) there is a family of general context-free parallel parsers that have the same efficiency in most practical cases (e.g. analysis of programming languages).},
  isbn = {978-3-540-06841-9},
  file = {/home/janek/Zotero/storage/4YNJ8MS6/978-3-662-21545-6_18.pdf}
}

@misc{LanguageServerProtocol,
  title = {Language {{Server Protocol Specification}}},
  url = {https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/},
  urldate = {2024-11-18},
  file = {/home/janek/Zotero/storage/AVFRJV3R/specification.html}
}

@article{leimeisterLanguageServerIDE,
  title = {A {{Language Server}} and {{IDE Plugin}} for {{CPAchecker}}},
  author = {Leimeister, Adrian},
  langid = {english},
  file = {/home/janek/Zotero/storage/H2G6B5QR/Leimeister - A Language Server and IDE Plugin for CPAchecker.pdf}
}

@misc{loopTreesitterNewParsing,
  title = {Tree-Sitter - a New Parsing System for Programming Tools - {{Strange Loop}}},
  author = {Loop, Strange},
  url = {https://www.thestrangeloop.com/2018/tree-sitter---a-new-parsing-system-for-programming-tools.html},
  urldate = {2023-12-06},
  abstract = {Strange Loop is a conference for software developers covering programming langs, databases, distributed systems, security, machine learning, creativity, and more!},
  langid = {english},
  file = {/home/janek/Zotero/storage/UULR3ZW3/tree-sitter---a-new-parsing-system-for-programming-tools.html}
}

@misc{MemorySafety,
  title = {Memory Safety},
  url = {https://www.chromium.org/Home/chromium-security/memory-safety/},
  urldate = {2024-10-17},
  file = {/home/janek/Zotero/storage/9XZ2BSB5/memory-safety.html}
}

@article{noyOntologyDevelopment101,
  title = {Ontology {{Development}} 101: {{A Guide}} to {{Creating Your First Ontology}}},
  author = {Noy, Natalya F and McGuinness, Deborah L},
  langid = {english},
  file = {/home/janek/Zotero/storage/JQCQCHL2/Noy and McGuinness - Ontology Development 101 A Guide to Creating Your First Ontology.pdf}
}

@misc{OwlcsOwlapi2024,
  title = {Owlcs/Owlapi},
  year = {2024},
  month = nov,
  url = {https://github.com/owlcs/owlapi},
  urldate = {2024-11-19},
  abstract = {OWL API main repository},
  howpublished = {owl.cs code, everything OWL related}
}

@misc{OWLWebOntologya,
  title = {{{OWL}} 2 {{Web Ontology Language Manchester Syntax}} ({{Second Edition}})},
  url = {https://www.w3.org/TR/owl2-manchester-syntax/},
  urldate = {2024-07-03},
  file = {/home/janek/Zotero/storage/KFICK5DM/owl2-manchester-syntax.html}
}

@misc{rfc-3629,
  title = {{{UTF-8}}, a Transformation Format of {{ISO}} 10646},
  url = {https://www.ietf.org/rfc/rfc3629.txt},
  urldate = {2024-10-10},
  file = {/home/janek/Zotero/storage/35X6DTDJ/rfc3629.html}
}

@misc{rfc-3987,
  title = {Internationalized {{Resource Identifiers}} ({{IRIs}})},
  url = {https://www.ietf.org/rfc/rfc3987.txt},
  urldate = {2024-10-10},
  file = {/home/janek/Zotero/storage/4WXKGK9U/rfc3987.html}
}

@misc{RopeImplementationOverview2017,
  title = {Rope {{Implementation Overview}}},
  year = {2017},
  month = dec,
  url = {https://web.archive.org/web/20171219030153/https://www.sgi.com/tech/stl/ropeimpl.html},
  urldate = {2024-11-01},
  file = {/home/janek/Zotero/storage/XII5L8GY/ropeimpl.html}
}

@misc{RustProgrammingLanguage,
  title = {The {{Rust Programming Language}} - {{The Rust Programming Language}}},
  url = {https://doc.rust-lang.org/book/},
  urldate = {2024-11-19},
  file = {/home/janek/Zotero/storage/YWABFEVG/book.html}
}

@article{sanderDesignImplementationLanguage,
  title = {Design and {{Implementation}} of the {{Language Server Protocol}} for the {{Nickel Language}}},
  author = {Sander, Yannik},
  abstract = {The expansive Language Integration, i.e. code completion, debugging as well as static code analysis, refactoring and more, has typically been the hallmark of Integrated Development Environments (IDE). Typical IDEs however focus on a selection of established languages to integrate which stifles the adoption of new languages. Contrasting IDEs, modular text editors allow for plugin driven integration of languages as contributed by their respective communities. Yet, providing language integration to multiple platforms requires repeated efforts for each one. The Language Server Protocol aims to be a solution to this problem by connecting a language specific Language Server to editors which act as generic clients. This work presents the design of a transferable Language Server architecture and its implementation for the Nickel languages. The product is finally evaluated quantitatively for its performance and qualitatively for its perception by future users.},
  langid = {english},
  file = {/home/janek/Zotero/storage/FEJ2TD3U/Sander - Design and Implementation of the Language Server P.pdf}
}

@misc{SyntaxErrorHighlighting,
  title = {Syntax and {{Error Highlighting}} {\textbar} {{IntelliJ Platform Plugin SDK}}},
  journal = {IntelliJ Platform Plugin SDK Help},
  url = {https://plugins.jetbrains.com/docs/intellij/syntax-highlighting-and-error-highlighting.html},
  urldate = {2024-11-19},
  langid = {american},
  file = {/home/janek/Zotero/storage/D3P5Y6JC/syntax-highlighting-and-error-highlighting.html}
}

@misc{SyntaxHighlightGuidea,
  title = {Syntax {{Highlight Guide}}},
  url = {https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide},
  urldate = {2024-11-19},
  abstract = {A guide to syntax highlighting},
  langid = {english},
  file = {/home/janek/Zotero/storage/59YM2JDB/syntax-highlight-guide.html}
}

@misc{TokioAsynchronousRust,
  title = {Tokio - {{An}} Asynchronous {{Rust}} Runtime},
  url = {https://tokio.rs/},
  urldate = {2024-10-17}
}

@misc{TreesitterIntroduction,
  title = {Tree-sitter｜{{Introduction}}},
  url = {https://tree-sitter.github.io/tree-sitter/},
  urldate = {2023-12-06},
  file = {/home/janek/Zotero/storage/PXPIMEBY/tree-sitter.html}
}

@inproceedings{vanwykContextawareScanningParsing2007,
  title = {Context-Aware Scanning for Parsing Extensible Languages},
  booktitle = {Proceedings of the 6th International Conference on {{Generative}} Programming and Component Engineering},
  author = {Van Wyk, Eric R. and Schwerdfeger, August C.},
  year = {2007},
  month = oct,
  pages = {63--72},
  publisher = {ACM},
  address = {Salzburg Austria},
  doi = {10.1145/1289971.1289983},
  url = {https://dl.acm.org/doi/10.1145/1289971.1289983},
  urldate = {2023-10-25},
  abstract = {This paper introduces new parsing and context-aware scanning algorithms in which the scanner uses contextual information to disambiguate lexical syntax. The parser uses a slightly modified LRstyle algorithm that passes to the scanner the set of valid symbols that the scanner may return at that point in parsing. This set is those terminals whose entries in the parse table for the current parse state are shift, reduce, or accept, but not error. The scanner then only returns tokens in this set. An analysis is given that can statically verify that the scanner will never return more than one token for a single input. Context-aware scanning is especially useful when parsing and scanning extensible languages in which domain specific languages can be embedded. It has been used in extensible versions of Java 1.4 and ANSI C. We illustrate this approach with a declarative specification of a subset of Java and extensions that embed SQL queries and Boolean expression tables into Java.},
  isbn = {978-1-59593-855-8},
  langid = {english},
  file = {/home/janek/Zotero/storage/VX7F8RDT/Van Wyk and Schwerdfeger - 2007 - Context-aware scanning for parsing extensible lang.pdf}
}

@article{wagnerEfficientFlexibleIncremental1998,
  title = {Efficient and Flexible Incremental Parsing},
  author = {Wagner, Tim A. and Graham, Susan L.},
  year = {1998},
  month = sep,
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {20},
  number = {5},
  pages = {980--1013},
  issn = {0164-0925, 1558-4593},
  doi = {10.1145/293677.293678},
  url = {https://dl.acm.org/doi/10.1145/293677.293678},
  urldate = {2023-11-21},
  abstract = {Previously published algorithms for LR (               k               ) incremental parsing are inefficient, unnecessarily restrictive, and in some cases incorrect. We present a simple algorithm based on parsing LR(               k               ) sentential forms that can incrementally parse an arbitrary number of textual and/or structural modifications in optimal time and with no storage overhead. The central role of               balanced sequences               in achieving truly incremental behavior from analysis algorithms is described, along with automated methods to support balancing during parse table generation and parsing. Our approach extends the theory of sentential-form parsing to allow for               ambiguity               in the grammar, exploiting it for notational convenience, to denote sequences, and to  construct compact (``abstract'') syntax trees directly. Combined, these techniques make the use of automatically generated incremental parsers in interactive software development environments both practical and effective. In addition, we address               information preservation               in these environments: Optimal node reuse is defined; previous definitions are shown to be insufficient; and a method for detecting node reuse is provided that is both simpler and faster than existing techniques. A program representation based on               self-versioning documents               is used to detect changes in the program, generate efficient change reports for subsequent analyses, and allow the parsing transformation itself to be treated as a reversible modification in the edit log.},
  langid = {english},
  file = {/home/janek/Zotero/storage/A259DPD9/Wagner and Graham - 1998 - Efficient and flexible incremental parsing.pdf}
}

@misc{wejdenstalXacrimonConcmapbench2024,
  title = {Xacrimon/Conc-Map-Bench},
  author = {Wejdenst{\aa}l, Joel},
  year = {2024},
  month = oct,
  url = {https://github.com/xacrimon/conc-map-bench},
  urldate = {2024-10-25}
}

@misc{wejdenstalXacrimonDashmap,
  title = {Xacrimon/Dashmap},
  author = {Wejdenst{\aa}l, Joel},
  url = {https://github.com/xacrimon/dashmap},
  urldate = {2024-10-25},
  abstract = {Blazingly fast concurrent map in Rust},
  file = {/home/janek/Zotero/storage/ERJFHACP/dashmap.html}
}

@misc{WhyTreesitterGithub,
  title = {Why Tree-Sitter at Github/Semantic},
  url = {https://github.com/github/semantic/blob/main/docs/why-tree-sitter.md},
  urldate = {2024-11-19},
  file = {/home/janek/Zotero/storage/YP9AJIKG/why-tree-sitter.html}
}
